# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.http.response import HttpResponsefrom django.shortcuts import renderfrom django.views import Viewfrom django.db.models import Qfrom django.contrib.auth.decorators import login_requiredimport simplejsonimport jsonfrom collections import namedtuplefrom ansible.parsing.dataloader import DataLoaderfrom ansible.vars import VariableManagerfrom ansible.inventory import Inventoryfrom ansible.playbook.play import Playfrom ansible.executor.task_queue_manager import TaskQueueManagerfrom ansible.plugins.callback import CallbackBaseimport MySQLdbfrom MySQLdb.constants.CLIENT import MULTI_STATEMENTS, MULTI_RESULTSfrom models import MysqlInstanceGroup, InstanceRelation, MysqlInstancefrom utils.log import my_logger# Create your views here.def index(request):    return render(request, 'base/base.html', {})class ResultCallback(CallbackBase):    def v2_runner_on_ok(self, result, **kwargs):        host = result._host        print(json.dumps({host.name: result._result}, indent=4))def ansible_run(host_list, task_list):    Options = namedtuple('Options',                         ['connection', 'module_path', 'forks', 'remote_user', 'private_key_file',                          'ssh_common_args', 'ssh_extra_args', 'sftp_extra_args', 'scp_extra_args',                          'become', 'become_method', 'become_user', 'verbosity', 'check'])    # initialize needed objects    variable_manager = VariableManager()    loader = DataLoader()    options = Options(connection='smart', module_path=None,                      forks=100, remote_user='root', private_key_file=None, ssh_common_args=None, ssh_extra_args=None,                      sftp_extra_args=None, scp_extra_args=None, become=None, become_method=None,                      become_user=None, verbosity=None, check=False                      )    passwords = dict(conn_pass='123456')    # Instantiate our ResultCallback for handling results as they come in    results_callback = ResultCallback()    # create inventory and pass to var manager    inventory = Inventory(loader=loader, variable_manager=variable_manager, host_list=host_list)    variable_manager.set_inventory(inventory)    # create play with tasks    play_source = dict(        name="Ansible Play",        hosts='all',        gather_facts='no',        tasks=task_list    )    play = Play().load(play_source, variable_manager=variable_manager, loader=loader)    # actually run it    tqm = None    try:        tqm = TaskQueueManager(            inventory=inventory, variable_manager=variable_manager,            loader=loader, options=options, passwords=passwords,            stdout_callback=results_callback,            # Use our custom callback instead of the ``default`` callback plugin        )        result = tqm.run(play)    finally:        if tqm is not None:            tqm.cleanup()@login_required(identity=('operation', ))def get_info(request):    host_list = ['192.168.0.249', '192.168.0.205', '192.168.0.237']    tasks_list = [        dict(action=dict(module='setup', args="")),    ]    ansible_run(host_list, tasks_list)    return HttpResponse('hello django', status=200)def run_meta_sql(sql, db_instance):    # TODO: 使用原生语句来获取数据库meta信息    try:        conn = MySQLdb.connect(host=db_instance.ip, user=db_instance.login_instance_account,                               passwd=db_instance.login_instance_password, db='mysql', port=db_instance.port,                               client_flag=MULTI_STATEMENTS | MULTI_RESULTS)        cur = conn.cursor()        ret = cur.execute(sql)        if ret:            result = cur.fetchall()        else:            return 'error'        cur.close()        conn.close()        return result    except MySQLdb.Error as e:        print('Mysql Error %d: %s' % (e.args[0], e.args[1]))        return 'error'def get_all_information():    groups = MysqlInstanceGroup.objects.all()    all_information = list()    for group in groups:        information = dict()        information['nodes'] = MysqlInstance.objects.filter(group=group)        information['group_name'] = group.name        all_information.append(information)    data = {        'all_information': all_information,    }    return data@login_required()def instance_list(request):    data = get_all_information()    data['sub_module'] = '1_2'    return render(request, 'statistic/instancelist.html', data)@login_required()def instance_pri_list(request):    data = get_all_information()    data['sub_module'] = '3_1'    return render(request, 'statistic/instance_pri_list.html', data)@login_required()def processlist(request):    ip = request.GET.get('ip')    port = request.GET.get('port', 3306)    instance = MysqlInstance.objects.get(Q(ip=ip) & Q(port=int(port)))    sql = 'show processlist;'    result = run_meta_sql(sql=sql, db_instance=instance)    data = {        'result': result,        'sub_module': '1_2'    }    return render(request, 'statistic/processlist.html', data)@login_required()def privileges_list(request):    ip = request.GET.get('ip')    port = request.GET.get('port', 3306)    instance = MysqlInstance.objects.get(Q(ip=ip) & Q(port=int(port)))    sql = 'SELECT user, host, Select_priv, Insert_priv, Update_priv, Delete_priv FROM mysql.user'    my_logger(level='info', username=request.user.name, message='读取权限列表，执行SQL: '+sql, path=request.path)    result = run_meta_sql(sql=sql, db_instance=instance)    data = {        'result': result,        'header': ('user', 'host', 'Select_priv', 'Insert_priv', 'Update_priv', 'Delete_priv'),        'ip': ip,        'port': port,        'sub_module': '3_1'    }    return render(request, 'statistic/privileges_list.html', data)@login_required()def ajax_get_privileges(request, *args, **kwargs):    ip = request.POST.get('ip')    port = request.POST.get('port', 3306)    host = request.POST.get('host')    user = request.POST.get('user')    sql = "show grants for '{}'@'{}'".format(user, host)    instance = MysqlInstance.objects.get(Q(ip=ip) & Q(port=int(port)))    result = run_meta_sql(sql=sql, db_instance=instance)    if result == 'error':        data = {            'result': '返回空的结果集或查询错误'        }    else:        str_format_result = ''        for res in result:            str_format_result = '{}{}{}'.format(str_format_result, '<br/>', res[0])        data = {            'result': str_format_result.lstrip('<br/>').replace('GRANT', '<span style="color: #337ab7;">GRANT</span>')        }    return HttpResponse(simplejson.dumps(data, ensure_ascii=False), content_type='application/json')@login_required()def topology(request):    groups = MysqlInstanceGroup.objects.all()    all_information = list()    for group in groups:        information = dict()        information['nodes'] = MysqlInstance.objects.filter(group=group)        information['links'] = InstanceRelation.objects.filter(belong_group=group)        information['group_name'] = group.name        all_information.append(information)    data = {        'all_information': all_information,        'sub_module': '1_1'    }    return render(request, 'statistic/topology.html', data)